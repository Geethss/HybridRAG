{
  "pdf_3a47f687_employee_data": {
    "schema": {
      "ID": "integer",
      "Name": "string",
      "Age": "integer",
      "City": "string",
      "Occupation": "string",
      "Salary": "currency"
    },
    "description": "## Table Description: `pdf_3a47f687_employee_data`\n\nThis document provides a comprehensive description of the `pdf_3a47f687_employee_data` table to facilitate accurate SQL query generation by an LLM.\n\n\n### 1. Table Metadata\n\n* **Table Name:** `pdf_3a47f687_employee_data`\n* **Table Purpose:** Stores information about employees.\n* **Columns:**\n    * `ID` (INT): Unique identifier for each employee record.  Serves as the primary key.\n    * `Name` (VARCHAR(255)): Employee's full name (text).\n    * `Age` (INT): Employee's age (whole number).\n    * `City` (VARCHAR(255)): City where the employee resides (text).\n    * `Occupation` (VARCHAR(255)): Employee's job title or occupation (text).\n    * `Salary` (FLOAT): Employee's annual salary (numeric, parsed from currency values, potentially including commas and a dollar sign in the source data).\n* **Key Identifier Columns:** `ID` (Primary Key)\n\n\n### 2. Sample Data Context\n\nThe sample data shows a small subset (10 rows) of employee records.  Each row represents a single employee with their ID, name, age, city of residence, occupation, and annual salary.  The `Salary` column contains numeric data that was likely parsed from text containing currency symbols (e.g., \"$80,000\").\n\n* **Data Format:**  The data is structured in a tabular format with each column representing a specific employee attribute.\n* **Typical Values:**  `ID` is an integer sequence; `Name` is a string; `Age` is a positive integer; `City` is a string representing a city name; `Occupation` is a string describing the job title; and `Salary` is a positive floating-point number representing annual income.\n\n\n### 3. Table Purpose\n\n* **Representation:** This table represents a list of employee records, containing basic demographic and employment information for each employee.\n* **Use Case:** The primary use case is to store and query employee data for various reporting, analysis, and HR-related tasks.\n\n\n### 4. Common Query Patterns\n\n* **Retrieve employee information:**  Selecting specific employee attributes (e.g., `Name`, `Age`, `Salary`) based on employee ID or other criteria.  Example: `SELECT Name, Age, Salary FROM pdf_3a47f687_employee_data WHERE ID = 5;`\n* **Filtering employees based on criteria:** Selecting employees who meet specific conditions (e.g., employees from a particular city, employees with a salary above a certain threshold, employees in a specific occupation). Example: `SELECT * FROM pdf_3a47f687_employee_data WHERE City = 'New York' AND Salary > 60000;`\n* **Aggregating employee data:** Calculating statistics on employee data (e.g., average salary, number of employees in each city). Example: `SELECT AVG(Salary) AS AverageSalary FROM pdf_3a47f687_employee_data;`  `SELECT COUNT(*) FROM pdf_3a47f687_employee_data GROUP BY City;`\n\n\n### 5. Data Characteristics\n\n* **Total Number of Records:** 10 (in the sample; the actual number may be different in the full dataset)\n* **Notable Data Patterns/Relationships:** The `ID` column serves as a unique identifier for each employee. There are no immediately apparent relationships with other tables (this would require information about the wider database schema).  The data appears to be relatively clean and consistent, but further analysis would be needed to confirm this for a larger dataset.  Note that the `Salary` column represents parsed numerical data, and may require special handling if further numerical analysis is performed.  The absence of any obvious errors in the provided sample suggests good data quality.",
    "file_hash": "3a47f687",
    "created_at": "2025-06-27T19:45:25.645348"
  },
  "pdf_3a47f687_product_inventory": {
    "schema": {
      "Serial No": "integer",
      "Product": "string",
      "Category": "string",
      "Price": "currency",
      "Stock": "integer"
    },
    "description": "## Table Description: `pdf_3a47f687_product_inventory`\n\n### 1. Table Metadata\n\n* **Table Name:** `pdf_3a47f687_product_inventory`\n* **Table Purpose:** This table stores information about products in an inventory.  It tracks each product's serial number, name, category, price, and current stock level.\n* **Columns:**\n    * `Serial No` (INT):  A unique serial number identifying each product entry.  This is likely the primary key.\n    * `Product` (VARCHAR(255)): The name of the product.\n    * `Category` (VARCHAR(255)): The category the product belongs to.\n    * `Price` (FLOAT): The price of the product. Note that the price is stored as a float after parsing from a currency string (e.g., \"$10.00\").\n    * `Stock` (INT): The current number of units in stock for the product.\n\n* **Key Identifier Column:** `Serial No` is the primary key, uniquely identifying each product record.\n\n\n### 2. Sample Data Context\n\nThe sample data shows a portion of the product inventory, listing each product with its serial number, name, category, price, and stock quantity.  The data is neatly organized in a tabular format.  `Serial No` values are sequential integers starting from 1. `Product` names are simple (e.g., \"Product 1\", \"Product 2\"), but in a real-world scenario, these would be more descriptive. `Category` values are text strings (e.g., \"Category A\", \"Category B\"). `Price` values are positive floating-point numbers representing monetary amounts, and `Stock` values are non-negative integers representing the number of items in stock.\n\n* **Data Format:** Tabular, with each row representing a single product.\n* **Typical Values:**\n    * `Serial No`: Integers from 1 to 96 (and presumably beyond in the full table).\n    * `Product`: Strings representing product names.\n    * `Category`: Strings representing product categories.\n    * `Price`: Positive floating-point numbers.\n    * `Stock`: Non-negative integers.\n\n\n### 3. Table Purpose\n\nThis table represents a product catalog and inventory tracking system.  It provides a central repository for information on available products, allowing for efficient management of stock levels and pricing.\n\n* **Main Use Case:** Managing product inventory, tracking stock levels, and retrieving product information for sales, reporting, or ordering purposes.\n\n\n### 4. Common Query Patterns\n\n* **Retrieve product information:**  Selecting specific product details based on `Serial No`, `Product` name, or `Category`.  For example: `SELECT * FROM pdf_3a47f687_product_inventory WHERE Product = 'Product 50';`\n* **Find products below a certain stock level:** Identifying low-stock items for reordering.  For example: `SELECT * FROM pdf_3a47f687_product_inventory WHERE Stock < 10;`\n* **Calculate the total value of inventory:** Aggregating the `Price` and `Stock` columns to determine the total inventory value.  For example: `SELECT SUM(Price * Stock) AS TotalInventoryValue FROM pdf_3a47f687_product_inventory;`\n\n\n### 5. Data Characteristics\n\n* **Total Number of Records:** 96 (as stated).\n* **Notable Data Patterns/Relationships:**  The `Serial No` acts as a primary key, uniquely identifying each product. There's a potential relationship between `Category` and other tables (e.g., a `Categories` table with more detailed category information), though this is not explicitly defined.  The data suggests a relatively small inventory; in a larger system, this table would likely contain many more records.  There's no obvious pattern in the `Product` names beyond sequential numbering in the sample data.",
    "file_hash": "3a47f687",
    "created_at": "2025-06-27T19:45:34.886069"
  },
  "pdf_3a47f687_product_categories": {
    "schema": {
      "product_id": "integer",
      "product_name": "string",
      "category": "string"
    },
    "description": "## Table Description: `pdf_3a47f687_product_categories`\n\n### 1. Table Metadata\n\n* **Table Name:** `pdf_3a47f687_product_categories`\n* **Table Purpose:**  This table appears intended to store information about product categories. However, the sample data suggests inconsistencies and potential data integrity issues (see section 2).  The actual purpose requires clarification.\n* **Column Names and Data Types:**\n    * `product_id`: `INT` (Whole numbers, ideally representing a unique identifier for each product)\n    * `product_name`: `VARCHAR(255)` (Text string representing the name of the product)\n    * `category`: `VARCHAR(255)` (Text string representing the category the product belongs to)\n* **Key Identifier Columns:**  `product_id` is likely intended to be a primary key, uniquely identifying each product.  However, based on sample data, this needs verification.\n\n\n### 2. Sample Data Context\n\nThe provided sample data is problematic and inconsistent.  It appears that each row might represent a different aspect of the data, potentially due to an error during data extraction from the original PDF (`pdf_3a47f687`).\n\n* **Row 1:**  Seems to represent product IDs/names/categories (e.g., Product 97 is in Category B).\n* **Row 2:** Seems to be category names themselves.\n* **Row 3:** Contains potentially monetary values (prices?).\n* **Row 4:** Appears to contain numerical identifiers, possibly representing some sort of internal ID or order.\n\n**Data Format and Typical Values:**  The format is inconsistent across rows.  The data types for `product_id`, `product_name`, and `category` are mixed and unreliable based on the sample.  Further investigation is needed to determine the intended data format and typical values.\n\n\n### 3. Table Purpose\n\nBased on the table name and *intended* schema, the table *should* represent a mapping between product IDs, product names, and their respective categories. It should function as a lookup table to retrieve product category information.  However, the sample data severely undermines this assertion and raises concerns about data quality and the table's true purpose.  Cleaning and correcting the data are crucial before using this table effectively.\n\n### 4. Common Query Patterns (Assuming Data Correction)\n\nAfter data cleaning and validation, common query patterns would include:\n\n1. **Retrieving product information by category:**  `SELECT product_id, product_name FROM pdf_3a47f687_product_categories WHERE category = 'Category A';`\n2. **Counting products in each category:** `SELECT category, COUNT(*) FROM pdf_3a47f687_product_categories GROUP BY category;`\n3. **Finding products with specific names:** `SELECT product_id, category FROM pdf_3a47f687_product_categories WHERE product_name LIKE '%Product%';`\n\n\n### 5. Data Characteristics\n\n* **Total Number of Records:** 4 (based on the provided information, but likely to be higher after data cleaning).\n* **Notable Data Patterns or Relationships:** No consistent patterns or relationships can be reliably identified due to the inconsistent and erroneous sample data.  A primary key constraint on `product_id` is expected (assuming data correction) to ensure uniqueness.  Further analysis is necessary to identify potential relationships with other tables.\n\n\n**Conclusion:** The `pdf_3a47f687_product_categories` table requires significant data cleaning and validation to be usable. The sample data is inconsistent and unreliable.  Once the data issues are resolved, the table can serve as a valuable lookup table for product category information.  The LLM should be instructed to verify data integrity before generating any queries against this table.",
    "file_hash": "3a47f687",
    "created_at": "2025-06-27T19:45:46.125866"
  }
}